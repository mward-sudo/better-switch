{"version":3,"file":"index.js","mappings":"AACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,sBCG3E,MCmDP,GAjCoCI,EAAOC,KACzC,IAEE,OAAOD,KAASC,EAAaA,EAAWD,KAAWC,EAAWC,UAC9D,MAAOC,GAEP,MAAM,IAAIC,MAIY,EAAuBD,EAAOH,EAAOC,KACzDE,OAAAA,aAAiBE,aD7BmD,MC+B5CL,GD9BtB,MC8B6BC,EAC7B,gDDZmD,OAA3BK,ECaRL,IDVtBV,OAAOgB,GAAGD,EAAOE,YAAajB,UCWxB,oEDjBmB,CAACS,GAAmC,iBAAVA,ECkB9CS,CAAYT,IACX,qDD/B0B,EAAsBA,EAAOC,IAC7DD,KAASC,GAA2C,mBAAtBA,EAAWD,GC+BpCU,CAAsBV,EAAOC,IAAU,sBAChBD,kED7BG,EAAsBA,EAAOC,IAC5D,YAAaA,GAA4C,mBAAvBA,EAAWC,QC6BxCS,CAAqBX,EAAOC,IAAU,sBACfD,wGD3BJ,EAAsBA,EAAOC,MACnDD,KAASC,MAAiB,YAAaA,GC2BpCW,CAAcZ,EAAOC,IAAU,kBACZD,mFAC4B,yCAKJG,KD5BnB,IAACG,GCIZO,CAAqBV,EAAOH,EAAOC,M","sources":["webpack://@scripthungry/better-switch/webpack/bootstrap","webpack://@scripthungry/better-switch/webpack/runtime/define property getters","webpack://@scripthungry/better-switch/webpack/runtime/hasOwnProperty shorthand","webpack://@scripthungry/better-switch/./src/runtime-checks.ts","webpack://@scripthungry/better-switch/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import type {BetterSwitchTest, CaseObject} from './types'\n\n// Both of the parameters are undefined or null\nexport const bothAreUndefinedOrNull: BetterSwitchTest = (match, caseObject) =>\n  (match === undefined || match === null) &&\n  (caseObject === undefined || caseObject === null)\n\n// Test if caseObject[match] exists and if caseObject[match] is not returning a function\nexport const matchKeyIsNotFunction: BetterSwitchTest = (match, caseObject) =>\n  match in caseObject && typeof caseObject[match] !== 'function'\n\n// Test if caseObject.defaul exists and if caseObject.defaul is not returning a function\nexport const defaultIsNotFunction: BetterSwitchTest = (match, caseObject) =>\n  'default' in caseObject && typeof caseObject.default !== 'function'\n\n/** Tests if caseObject[match] does not exist and if caseObject.default does not exist */\nexport const noKeyToReturn: BetterSwitchTest = (match, caseObject) =>\n  !(match in caseObject) && !('default' in caseObject)\n\n/** Test if match is not a string */\nexport const isNotString = (match: string) => typeof match !== 'string'\n\n// Test if parameter is an object literal\nexport const isObjectLiteral = (object: CaseObject<unknown>) =>\n  object !== null &&\n  object !== undefined &&\n  Object.is(object.constructor, Object)\n","import type {BetterSwitch, BetterSwitchError} from './types'\nimport {\n  bothAreUndefinedOrNull,\n  defaultIsNotFunction,\n  isNotString,\n  isObjectLiteral,\n  matchKeyIsNotFunction,\n  noKeyToReturn,\n} from './runtime-checks'\n\n/**\n * A simple switch statement replacement that matches a string key and returns a value\n *\n * @param match - A string which should match a key in caseObject.\n * @param caseObject - An object with a string key with a value containing a function that\n *                     returns something.\n *                     A key of 'default' can be used to return a value if the parameter\n *                     match does not match a key in caseObject.\n *                     In typescript the returned values must all be of the same type\n * @returns The value from the matching or default key from caseObject\n */\nconst betterSwitch: BetterSwitch = (match, caseObject) => {\n  try {\n    // If caseObject[match]() does not exist, return caseObject.default()\n    return match in caseObject ? caseObject[match]() : caseObject.default()\n  } catch (error: unknown) {\n    // Handle errors when trying to call caseObject[match]() or caseObject.default()\n    throw new Error(generateErrorMessage(error, match, caseObject))\n  }\n}\n\nconst generateErrorMessage: BetterSwitchError = (error, match, caseObject) => {\n  if (error instanceof TypeError) {\n    return (\n      (bothAreUndefinedOrNull(match, caseObject) &&\n        'BetterSwitch: No arguments have been passed') ||\n      (!isObjectLiteral(caseObject) &&\n        'BetterSwitch: The caseObject parameter is not an object literal') ||\n      (isNotString(match) &&\n        'BetterSwitch: The match parameter is not a string') ||\n      (matchKeyIsNotFunction(match, caseObject) &&\n        `BetterSwitch: The '${match}' key in your caseObject parameter does not return a function`) ||\n      (defaultIsNotFunction(match, caseObject) &&\n        `BetterSwitch: The '${match}' key in your caseObject parameter does not exist, and the 'default' key does not return a function`) ||\n      (noKeyToReturn(match, caseObject) &&\n        `BetterSwitch: '${match}' is not a key in your caseObject parameter, and no 'default' key is provided`) ||\n      `BetterSwitch: Unhandled error (${typeof error})`\n    )\n  }\n\n  // Shouldn't hit this\n  return `BetterSwitch: Unhandled error (${typeof error})`\n}\n\nexport default betterSwitch\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","match","caseObject","default","error","Error","TypeError","object","is","constructor","isNotString","matchKeyIsNotFunction","defaultIsNotFunction","noKeyToReturn","generateErrorMessage"],"sourceRoot":""}