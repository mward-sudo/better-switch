{"version":3,"file":"index.js","mappings":"AACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,sBC8BlF,MA2CA,GAtDoCI,EAAOC,KACzC,IAEE,OAAOD,KAASC,EAAaA,EAAWD,KAAWC,EAAWC,UAC9D,MAAOC,GAEP,MAAM,IAAIC,MAiBY,EAAuBD,EAAOH,EAAOC,KAC7D,GAAIE,aAAiBE,UAAW,CAC9B,GAd+D,MAcpCL,GAd+C,MAcxCC,EAChC,MAAO,8CAGT,IARoB,CAACK,GAA2B,MAAKA,GAA2Cf,OAAOgB,GAAGD,EAAOE,YAAajB,QAQzHkB,CAAgBR,GACnB,MAAO,kEAGT,GAdgB,CAACD,GAAmC,iBAAVA,EActCU,CAAYV,GACd,MAAO,oDAGT,GAxBuB,EAAsBA,EAAOC,IAAeD,KAASC,GAA2C,mBAAtBA,EAAWD,GAwBxGW,CAAsBX,EAAOC,GAC/B,MAAO,sBAAsBD,iEAG/B,GA1BsB,EAAsBA,EAAOC,IAAe,YAAaA,GAA4C,mBAAvBA,EAAWC,QA0B3GU,CAAqBZ,EAAOC,GAC9B,MAAO,sBAAsBD,uGAG/B,GA5Be,EAAsBA,EAAOC,MAAiBD,KAASC,MAAiB,YAAaA,GA4BhGY,CAAcb,EAAOC,GACvB,MAAO,kBAAkBD,iFAK7B,MAAO,yCAAyCG,MA7C9BW,CAAqBX,EAAOH,EAAOC,M","sources":["webpack://@scripthungry/better-switch/webpack/bootstrap","webpack://@scripthungry/better-switch/webpack/runtime/define property getters","webpack://@scripthungry/better-switch/webpack/runtime/hasOwnProperty shorthand","webpack://@scripthungry/better-switch/./index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","type BetterSwitch = <T>(match: string, caseObject: CaseObject<T>) => T\ntype CaseObject<T> = Record<string, CaseObjectFunction<T>>\ntype CaseObjectFunction<T> = () => T\n\n// BetterSwitchTest and BetterSwitchError both reuse the parameters from BetterSwitch\ntype BetterSwitchTest = (...args: Parameters<BetterSwitch>) => boolean\ntype BetterSwitchError = (error: unknown, ...args: Parameters<BetterSwitch>) => string\n\n/**\n * A simple switch statement replacement that matches a string key and returns a value\n *\n * @param match - A string which should match a key in caseObject.\n * @param caseObject - An object with a string key with a value containing a function that\n *                     returns something.\n *                     A key of 'default' can be used to return a value if the parameter\n *                     match does not match a key in caseObject.\n *                     In typescript the returned values must all be of the same type\n * @returns The value from the matching or default key from caseObject\n */\nconst betterSwitch: BetterSwitch = (match, caseObject) => {\n  try {\n    // If caseObject[match]() does not exist, return caseObject.default()\n    return match in caseObject ? caseObject[match]() : caseObject.default()\n  } catch (error: unknown) {\n    // Handle errors when trying to call caseObject[match]() or caseObject.default()\n    throw new Error(generateErrorMessage(error, match, caseObject))\n  }\n}\n\n// Both of the parameters are undefined or null\nconst bothAreUndefinedOrNull: BetterSwitchTest = (match, caseObject) => (match === undefined || match === null) && (caseObject === undefined || caseObject === null)\n// Test if caseObject[match] exists and if caseObject[match] is not returning a function\nconst matchKeyIsNotFunction: BetterSwitchTest = (match, caseObject) => match in caseObject && typeof caseObject[match] !== 'function'\n// Test if caseObject.defaul exists and if caseObject.defaul is not returning a function\nconst defaultIsNotFunction: BetterSwitchTest = (match, caseObject) => 'default' in caseObject && typeof caseObject.default !== 'function'\n/** Tests if caseObject[match] does not exist and if caseObject.default does not exist */\nconst noKeyToReturn: BetterSwitchTest = (match, caseObject) => !(match in caseObject) && !('default' in caseObject)\n/** Test if match is not a string */\nconst isNotString = (match: string) => typeof match !== 'string'\n// Test if parameter is an object literal\nconst isObjectLiteral = (object: CaseObject<unknown>) => object !== null && object !== undefined && Object.is(object.constructor, Object)\n\nconst generateErrorMessage: BetterSwitchError = (error, match, caseObject) => {\n  if (error instanceof TypeError) {\n    if (bothAreUndefinedOrNull(match, caseObject)) {\n      return 'BetterSwitch: No arguments have been passed'\n    }\n\n    if (!isObjectLiteral(caseObject)) {\n      return 'BetterSwitch: The caseObject parameter is not an object literal'\n    }\n\n    if (isNotString(match)) {\n      return 'BetterSwitch: The match parameter is not a string'\n    }\n\n    if (matchKeyIsNotFunction(match, caseObject)) {\n      return `BetterSwitch: The '${match}' key in your caseObject parameter does not return a function`\n    }\n\n    if (defaultIsNotFunction(match, caseObject)) {\n      return `BetterSwitch: The '${match}' key in your caseObject parameter does not exist, and the 'default' key does not return a function`\n    }\n\n    if (noKeyToReturn(match, caseObject)) {\n      return `BetterSwitch: '${match}' is not a key in your caseObject parameter, and no 'default' key is provided`\n    }\n  }\n\n  // Shouldn't hit this\n  return `BetterSwitch: Unhandled error (${typeof error})`\n}\n\nexport default betterSwitch\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","match","caseObject","default","error","Error","TypeError","object","is","constructor","isObjectLiteral","isNotString","matchKeyIsNotFunction","defaultIsNotFunction","noKeyToReturn","generateErrorMessage"],"sourceRoot":""}